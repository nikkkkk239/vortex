<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum-Enhanced Medical Imaging AI System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            min-height: 100vh;
            color: #fff;
            overflow-x: hidden;
            position: relative;
        }
        
        /* Animated gradient background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, 
                #000000 0%, 
                #1a1a1a 25%, 
                #333333 50%, 
                #1a1a1a 75%, 
                #000000 100%);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            z-index: -2;
        }
        
        /* Moving particles effect */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, #fff, transparent),
                radial-gradient(2px 2px at 40px 70px, #fff, transparent),
                radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                radial-gradient(1px 1px at 130px 80px, #fff, transparent),
                radial-gradient(2px 2px at 160px 30px, #fff, transparent);
            background-repeat: repeat;
            background-size: 200px 100px;
            animation: particleMove 20s linear infinite;
            z-index: -1;
            opacity: 0.1;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes particleMove {
            0% { transform: translateY(0px); }
            100% { transform: translateY(-100px); }
        }
        
        /* Floating geometric shapes */
        .floating-shapes {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        
        .shape {
            position: absolute;
            opacity: 0.05;
            animation: float 15s infinite ease-in-out;
        }
        
        .shape:nth-child(1) {
            width: 80px;
            height: 80px;
            background: linear-gradient(45deg, #fff, #ccc);
            border-radius: 20px;
            top: 10%;
            left: 10%;
            animation-delay: 0s;
        }
        
        .shape:nth-child(2) {
            width: 60px;
            height: 60px;
            background: linear-gradient(45deg, #ccc, #fff);
            border-radius: 50%;
            top: 20%;
            right: 10%;
            animation-delay: 3s;
        }
        
        .shape:nth-child(3) {
            width: 100px;
            height: 100px;
            background: linear-gradient(45deg, #fff, #999);
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
            bottom: 20%;
            left: 20%;
            animation-delay: 6s;
        }
        
        .shape:nth-child(4) {
            width: 70px;
            height: 70px;
            background: linear-gradient(45deg, #999, #fff);
            border-radius: 10px;
            bottom: 30%;
            right: 20%;
            animation-delay: 9s;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            25% { transform: translateY(-20px) rotate(90deg); }
            50% { transform: translateY(-40px) rotate(180deg); }
            75% { transform: translateY(-20px) rotate(270deg); }
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            position: relative;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #fff, #ccc, #fff);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: textShimmer 3s ease-in-out infinite;
            text-shadow: 0 0 30px rgba(255,255,255,0.3);
            position: relative;
        }
        
        .header h1::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            animation: shimmer 2s infinite;
        }
        
        .header p {
            font-size: 1.2rem;
            opacity: 0.8;
            color: #ccc;
            text-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        
        @keyframes textShimmer {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .main-content {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0,0,0,0.3), 0 0 100px rgba(255,255,255,0.1);
            overflow: hidden;
            position: relative;
        }
        
        .main-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, 
                rgba(255,255,255,0.1) 0%, 
                rgba(255,255,255,0.05) 50%, 
                rgba(255,255,255,0.1) 100%);
            animation: contentShimmer 4s ease-in-out infinite;
            z-index: -1;
        }
        
        @keyframes contentShimmer {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }
        
        .tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .tab {
            flex: 1;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 1rem;
            font-weight: 600;
            color: #ccc;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.1), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .tab:hover::before {
            opacity: 1;
        }
        
        .tab.active {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            border-bottom: 3px solid #fff;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
        }
        
        .tab:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .tab-content {
            padding: 40px;
            display: none;
            position: relative;
            z-index: 1;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .upload-area {
            border: 3px dashed rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .upload-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }
        
        .upload-area:hover::before {
            left: 100%;
        }
        
        .upload-area:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.05);
            box-shadow: 0 0 30px rgba(255,255,255,0.1);
            transform: translateY(-2px);
        }
        
        .upload-area.dragover {
            border-color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 40px rgba(255,255,255,0.2);
        }
        
        .upload-icon {
            font-size: 4rem;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
            animation: iconPulse 2s ease-in-out infinite;
        }
        
        .upload-text {
            font-size: 1.2rem;
            color: #fff;
            margin-bottom: 10px;
            text-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        
        .upload-subtext {
            font-size: 0.9rem;
            color: #ccc;
            opacity: 0.8;
        }
        
        @keyframes iconPulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
        
        /* Image Preview Styles */
        .image-previews {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 20px;
            justify-content: center;
            align-items: start;
        }
        
        .preview-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            width: 100%;
            max-width: 250px;
            margin: 0 auto;
        }
        
        .preview-container h4 {
            color: #fff;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        
        .preview-image {
            width: 100%;
            height: auto;
            max-width: 100%;
            max-height: 200px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
            object-fit: contain;
        }
        
        .preview-image:hover {
            transform: scale(1.05);
        }
        
        #3dCanvas, #heatmapCanvas {
            width: 100%;
            height: auto;
            max-width: 100%;
            max-height: 200px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            background: rgba(0, 0, 0, 0.3);
            cursor: grab;
            aspect-ratio: 1;
        }
        
        #3dCanvas:active, #heatmapCanvas:active {
            cursor: grabbing;
        }
        
        .file-input {
            display: none;
        }
        
        .btn {
            background: linear-gradient(135deg, rgba(255,255,255,0.2), rgba(255,255,255,0.1));
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 15px 30px;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 30px rgba(255,255,255,0.2);
            border-color: rgba(255, 255, 255, 0.5);
            background: linear-gradient(135deg, rgba(255,255,255,0.3), rgba(255,255,255,0.2));
        }
        
        .btn:disabled {
            background: rgba(255,255,255,0.1);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.5;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.05));
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .analysis-section {
            margin-top: 30px;
            padding: 30px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, rgba(255,255,255,0.8), rgba(255,255,255,0.6));
            width: 0%;
            transition: width 0.5s ease;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
            animation: progressGlow 2s ease-in-out infinite;
        }
        
        @keyframes progressGlow {
            0%, 100% { box-shadow: 0 0 10px rgba(255,255,255,0.3); }
            50% { box-shadow: 0 0 20px rgba(255,255,255,0.5); }
        }
        
        .result-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }
        
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }
        
        .confidence-meter {
            display: flex;
            align-items: center;
            margin: 15px 0;
            color: #fff;
        }
        
        .confidence-bar {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            margin: 0 15px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .confidence-fill {
            height: 100%;
            border-radius: 8px;
            transition: width 0.8s ease;
            box-shadow: 0 0 10px rgba(255,255,255,0.3);
        }
        
        .confidence-high { 
            background: linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
            box-shadow: 0 0 15px rgba(255,255,255,0.4);
        }
        .confidence-medium { 
            background: linear-gradient(90deg, rgba(255,255,255,0.7), rgba(255,255,255,0.5));
            box-shadow: 0 0 12px rgba(255,255,255,0.3);
        }
        .confidence-low { 
            background: linear-gradient(90deg, rgba(255,255,255,0.5), rgba(255,255,255,0.3));
            box-shadow: 0 0 8px rgba(255,255,255,0.2);
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin: 30px 0;
        }
        
        .feature-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .feature-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.05), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .feature-card:hover::before {
            opacity: 1;
        }
        
        .feature-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 50px rgba(0,0,0,0.3);
            border-color: rgba(255, 255, 255, 0.2);
        }
        
        .feature-icon {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 0 0 20px rgba(255,255,255,0.3);
            animation: iconFloat 3s ease-in-out infinite;
        }
        
        .feature-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 15px;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.2);
        }
        
        .feature-description {
            color: #ccc;
            line-height: 1.6;
            opacity: 0.9;
        }
        
        @keyframes iconFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        
        .chat-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
        }
        
        .chat-message {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 12px;
            max-width: 80%;
            backdrop-filter: blur(5px);
        }
        
        .chat-message.user {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            margin-left: auto;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 5px 15px rgba(255,255,255,0.1);
        }
        
        .chat-message.assistant {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        
        .chat-input-container {
            display: flex;
            gap: 10px;
        }
        
        .chat-input {
            flex: 1;
            padding: 15px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            font-size: 1rem;
            resize: vertical;
            min-height: 50px;
            background: rgba(255, 255, 255, 0.05);
            color: #fff;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        
        .chat-input::placeholder {
            color: #ccc;
            opacity: 0.8;
        }
        
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            transition: transform 0.3s ease;
        }
        
        .metric-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
        }
        
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fff;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255,255,255,0.3);
        }
        
        .metric-label {
            color: #ccc;
            font-weight: 600;
            opacity: 0.9;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 40px;
            color: #fff;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top: 3px solid #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
            box-shadow: 0 0 20px rgba(255,255,255,0.3);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .alert {
            padding: 15px;
            border-radius: 12px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .alert-success {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            color: #fff;
            box-shadow: 0 0 20px rgba(255,255,255,0.1);
        }
        
        .alert-error {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.2);
            color: #fff;
            box-shadow: 0 0 20px rgba(255,255,255,0.05);
        }
        
        .alert-warning {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.25);
            color: #fff;
            box-shadow: 0 0 20px rgba(255,255,255,0.08);
        }
        
        @media (max-width: 768px) {
            .tabs {
                flex-direction: column;
            }
            
            .tab-content {
                padding: 20px;
            }
            
            .feature-grid {
                grid-template-columns: 1fr;
            }
            
            .dashboard-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
            
            /* Responsive image previews for mobile */
            .image-previews {
                grid-template-columns: 1fr;
                gap: 10px;
                margin-top: 15px;
            }
            
            .preview-container {
                padding: 10px;
                max-width: 100%;
            }
            
            .preview-container h4 {
                font-size: 0.8rem;
                margin-bottom: 8px;
            }
            
            .preview-image {
                max-height: 150px;
            }
            
            #3dCanvas, #heatmapCanvas {
                max-height: 150px;
            }
        }
        
        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }
            
            .header p {
                font-size: 1rem;
            }
            
            .tab-content {
                padding: 15px;
            }
            
            .upload-area {
                padding: 40px 15px;
            }
            
            .image-previews {
                grid-template-columns: 1fr;
                gap: 8px;
            }
            
            .preview-container {
                padding: 8px;
            }
            
            .preview-container h4 {
                font-size: 0.75rem;
            }
            
            .preview-image, #3dCanvas, #heatmapCanvas {
                max-height: 120px;
            }
        }
        
        @media (min-width: 1200px) {
            .image-previews {
                grid-template-columns: repeat(3, 1fr);
                max-width: 900px;
                margin: 20px auto;
            }
            
            .preview-container {
                max-width: 280px;
            }
            
            .preview-image, #3dCanvas, #heatmapCanvas {
                max-height: 250px;
            }
        }
    </style>
</head>
<body>
    <!-- Floating geometric shapes -->
    <div class="floating-shapes">
        <div class="shape"></div>
        <div class="shape"></div>
        <div class="shape"></div>
        <div class="shape"></div>
    </div>
    
    <div class="container">
        <div class="header">
            <h1> Quantum-Enhanced Medical Imaging AI</h1>
            <p>Advanced Medical Image Analysis with Quantum Computing & Explainable AI</p>
            <p style="margin-top: 10px;font-size: 15px;">Book an appointment right now with our AI agent :- +1 470 250 3144  </p>
        </div>
        
        <div class="main-content">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('analyze')"> Analyze</button>
                <button class="tab" onclick="switchTab('chat')"> Chat</button>
                <button class="tab" onclick="switchTab('dashboard')"> Dashboard</button>
                <button class="tab" onclick="switchTab('about')"> About</button>
            </div>
            
            <!-- Analyze Tab -->
            <div id="analyze" class="tab-content active">
                <div class="upload-area" onclick="document.getElementById('fileInput').click()" 
                     ondrop="handleDrop(event)" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)">
                    <div class="upload-icon"></div>
                    <div class="upload-text">Drag & drop medical images here</div>
                    <div class="upload-subtext">Supports DICOM, NIfTI, JPG, PNG formats</div>
                    <input type="file" id="fileInput" class="file-input" accept=".dcm,.nii,.nii.gz,.jpg,.jpeg,.png" onchange="handleFileSelect(event)">
                </div>
                
                <div style="text-align: center;">
                    <button class="btn" onclick="startAnalysis()" id="analyzeBtn" disabled>
                         Start Quantum Analysis
                    </button>
                    <button class="btn btn-secondary" onclick="useDemo()">
                         Use Demo Image
                    </button>
                </div>
                
                <div class="loading" id="loading">
                    <div class="spinner"></div>
                    <p>Analyzing with Quantum-Enhanced AI...</p>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
                
                <div class="analysis-section" id="analysisResults" style="display: none;">
                    <h3> Analysis Results</h3>
                    <div id="resultsContent"></div>
                </div>
            </div>
            
            <!-- Chat Tab -->
            <div id="chat" class="tab-content">
                <h3>ðŸ©º Medical AI Consultant</h3>
                <p>Chat with our AI system for medical insights and explanations</p>
                
                <div class="chat-container" id="chatContainer">
                    <div class="chat-message assistant">
                        <strong>Medical AI:</strong> Hello! I'm your quantum-enhanced medical AI assistant. 
                        I can help analyze medical images, explain findings, and provide clinical insights. 
                        How can I assist you today?
                    </div>
                </div>
                
                <div class="chat-input-container">
                    <textarea class="chat-input" id="chatInput" placeholder="Ask about medical imaging, analysis results, or clinical questions..."
                              onkeypress="handleChatKeyPress(event)"></textarea>
                    <button class="btn" onclick="sendMessage()">Send</button>
                </div>
            </div>
            
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content">
                <h3> System Dashboard</h3>
                
                <div class="dashboard-grid">
                    <div class="metric-card">
                        <div class="metric-value" id="totalAnalyses">0</div>
                        <div class="metric-label">Total Analyses</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="avgConfidence">0%</div>
                        <div class="metric-label">Avg Confidence</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="quantumEnhanced">0%</div>
                        <div class="metric-label">Quantum Enhanced</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="processingTime">0s</div>
                        <div class="metric-label">Avg Processing</div>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4 Recent Activity</h4>
                    <div id="recentActivity">
                        <p style="color: #6c757d; text-align: center; padding: 20px;">
                            No recent analyses. Start by uploading a medical image in the Analyze tab.
                        </p>
                    </div>
                </div>
            </div>
            
            <!-- About Tab -->
            <div id="about" class="tab-content">
                <h3> About This System</h3>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <div class="feature-icon"></div>
                        <div class="feature-title">Quantum Enhancement</div>
                        <div class="feature-description">
                            Leverages quantum computing for advanced feature extraction and uncertainty quantification,
                            providing more accurate and robust medical image analysis.
                        </div>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon"></div>
                        <div class="feature-title">LLaVA-Med Integration</div>
                        <div class="feature-description">
                            Built on Microsoft's LLaVA-Med v1.5 with Mistral-7B, specifically fine-tuned for
                            medical imaging tasks and clinical decision support.
                        </div>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon"></div>
                        <div class="feature-title">Explainable AI</div>
                        <div class="feature-description">
                            Implements Grad-CAM, LIME, and SHAP for transparent decision-making,
                            ensuring clinical interpretability and regulatory compliance.
                        </div>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon"></div>
                        <div class="feature-title">HIPAA Compliant</div>
                        <div class="feature-description">
                            Designed with healthcare privacy and security in mind, including encrypted data handling
                            and comprehensive audit logging.
                        </div>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon"></div>
                        <div class="feature-title">Clinical Dashboard</div>
                        <div class="feature-description">
                            Interactive analytics dashboard with confidence metrics, finding distributions,
                            and risk assessment visualizations for clinical workflow integration.
                        </div>
                    </div>
                    
                    <div class="feature-card">
                        <div class="feature-icon"></div>
                        <div class="feature-title">AI Consultation</div>
                        <div class="feature-description">
                            GPT-4 Vision integrated medical chatbot providing doctor-perspective insights
                            and explanations for enhanced clinical decision support.
                        </div>
                    </div>
                </div>
                
                <div class="result-card">
                    <h4>Technical Specifications</h4>
                    <ul style="line-height: 1.8; color: #6c757d;">
                        <li><strong>Quantum Framework:</strong> Qiskit 0.45.0+ with PennyLane integration</li>
                        <li><strong>Vision Model:</strong> Microsoft LLaVA-Med v1.5 (Mistral-7B)</li>
                        <li><strong>Medical Formats:</strong> DICOM, NIfTI, standard imaging formats</li>
                        <li><strong>XAI Methods:</strong> Grad-CAM, LIME, SHAP interpretability</li>
                        <li><strong>API Framework:</strong> Flask with JWT authentication</li>
                        <li><strong>Deployment:</strong> Docker containerization with GPU support</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let selectedFile = null;
        let analysisHistory = [];
        let animationId = null;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let rotationX = 0;
        let rotationY = 0;
        let depthMap = null;
        
        // Arrays for random analysis values
        const confidenceValues = [];
        const processingTimes = [];
        const riskLevels = ['Low', 'Medium', 'High'];
        
        // Generate confidence values from 75% to 100%
        for (let i = 75; i <= 100; i++) {
            confidenceValues.push(i);
        }
        
        // Generate processing times from 1 to 5 seconds
        for (let i = 1; i <= 47; i++) {
            processingTimes.push((i / 10).toFixed(1)); // 0.1 to 5.0 seconds
        }
        
        // Tab switching
        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }
        
        // File handling
        function handleDragOver(event) {
            event.preventDefault();
            event.currentTarget.classList.add('dragover');
        }
        
        function handleDragLeave(event) {
            event.currentTarget.classList.remove('dragover');
        }
        
        function handleDrop(event) {
            event.preventDefault();
            event.currentTarget.classList.remove('dragover');
            
            const files = event.dataTransfer.files;
            if (files.length > 0) {
                selectedFile = files[0];
                updateUploadArea();
            }
        }
        
        function handleFileSelect(event) {
            selectedFile = event.target.files[0];
            // Stop any existing animation and reset rotation
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            rotationX = 0;
            rotationY = 0;
            updateUploadArea();
        }
        
        function updateUploadArea() {
            const uploadArea = document.querySelector('.upload-area');
            const analyzeBtn = document.getElementById('analyzeBtn');
            
            if (selectedFile) {
                // Create image preview and 3D visualization
                const reader = new FileReader();
                reader.onload = function(e) {
                    const imageDataUrl = e.target.result;
                    
                uploadArea.innerHTML = `
                        <div class="upload-icon"></div>
                    <div class="upload-text">File Selected: ${selectedFile.name}</div>
                    <div class="upload-subtext">Size: ${(selectedFile.size / 1024 / 1024).toFixed(2)} MB</div>
                        
                        <div class="image-previews">
                            <div class="preview-container">
                                <h4>Original 2D Image</h4>
                                <img src="${imageDataUrl}" alt="Original Image" class="preview-image" id="originalImage">
                            </div>
                            <div class="preview-container">
                                <h4>Heat Map Analysis</h4>
                                <canvas id="heatmapCanvas"></canvas>
                            </div>
                            <div class="preview-container">
                                <h4>3D Visualization</h4>
                                <canvas id="3dCanvas"></canvas>
                            </div>
                        </div>
                    `;
                    
                    // Generate both 3D visualization and heat map
                    generate3DPreview(imageDataUrl);
                    generateHeatMap(imageDataUrl);
                };
                reader.readAsDataURL(selectedFile);
                analyzeBtn.disabled = false;
            }
        }
        
        function generate3DPreview(imageDataUrl) {
            setTimeout(() => {
                const canvas = document.getElementById('3dCanvas');
                if (!canvas) return;
                
                // Set responsive canvas size
                const container = canvas.parentElement;
                const maxSize = Math.min(container.clientWidth - 30, 250);
                canvas.width = maxSize;
                canvas.height = maxSize;
                
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // Create 3D effect by processing the image
                    create3DEffect(ctx, img, canvas.width, canvas.height);
                };
                
                img.src = imageDataUrl;
            }, 100);
        }
        
        function generateHeatMap(imageDataUrl) {
            setTimeout(() => {
                const canvas = document.getElementById('heatmapCanvas');
                if (!canvas) return;
                
                // Set responsive canvas size
                const container = canvas.parentElement;
                const maxSize = Math.min(container.clientWidth - 30, 250);
                canvas.width = maxSize;
                canvas.height = maxSize;
                
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                img.onload = function() {
                    // Create heat map effect by processing the image
                    createHeatMapEffect(ctx, img, canvas.width, canvas.height);
                };
                
                img.src = imageDataUrl;
            }, 100);
        }
        
        function createHeatMapEffect(ctx, img, width, height) {
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Create a temporary canvas to process the image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            
            // Draw the original image scaled to canvas size
            tempCtx.drawImage(img, 0, 0, width, height);
            
            // Get image data for processing
            const imageData = tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Create heat map data
            const heatMapData = [];
            for (let i = 0; i < data.length; i += 4) {
                // Calculate grayscale intensity
                const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                heatMapData.push(gray);
            }
            
            // Draw heat map visualization
            drawHeatMap(ctx, heatMapData, width, height);
        }
        
        function create3DEffect(ctx, img, width, height) {
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Create a temporary canvas to process the image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            
            // Draw the original image scaled to canvas size
            tempCtx.drawImage(img, 0, 0, width, height);
            
            // Get image data for processing
            const imageData = tempCtx.getImageData(0, 0, width, height);
            const data = imageData.data;
            
            // Create 3D depth effect based on pixel intensity
            depthMap = [];
            for (let i = 0; i < data.length; i += 4) {
                // Calculate grayscale intensity
                const gray = (data[i] + data[i + 1] + data[i + 2]) / 3;
                // Convert to depth (darker = closer)
                const depth = (255 - gray) / 255;
                depthMap.push(depth);
            }
            
            // Reset rotation when new image is loaded
            rotationX = 0;
            rotationY = 0;
            
            // Draw 3D visualization
            draw3DVisualization(ctx, depthMap, width, height);
            
            // Add mouse event listeners for interaction
            add3DInteractivity(ctx, width, height);
        }
        
        function draw3DVisualization(ctx, depthMap, width, height) {
            // Set up 3D rendering parameters
            const centerX = width / 2;
            const centerY = height / 2;
            const maxDepth = 60; // Increased depth for more dramatic effect
            
            // Clear canvas with dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, width, height);
            
            // Draw 3D points with much higher density
            const step = 2; // Sample every 2 pixels for more dots
            const points = [];
            
            // First pass: collect all points
            for (let y = 0; y < height; y += step) {
                for (let x = 0; x < width; x += step) {
                    const index = y * width + x;
                    if (index < depthMap.length) {
                        const depth = depthMap[index];
                        
                        // Only draw points with sufficient depth
                        if (depth > 0.02) {
                            points.push({
                                x: x - centerX,
                                y: y - centerY,
                                z: depth * maxDepth,
                                depth: depth
                            });
                        }
                    }
                }
            }
            
            // Sort points by Z-depth for proper rendering
            points.sort((a, b) => b.z - a.z);
            
            // Second pass: render points
            points.forEach(point => {
                // Apply user-controlled rotation
                const rotatedPoint = rotatePoint(point, rotationX, rotationY);
                
                // Project to 2D screen coordinates
                const scale = 200 / (200 + rotatedPoint.z);
                const screenX = centerX + rotatedPoint.x * scale;
                const screenY = centerY + rotatedPoint.y * scale;
                
                // Skip points that are behind the camera
                if (rotatedPoint.z < -50) return;
                
                // Set point color and size based on depth
                const intensity = Math.min(255, point.depth * 255 + 80);
                const alpha = Math.min(0.9, point.depth * 2);
                const size = Math.max(0.5, point.depth * 2 + 0.5);
                
                ctx.fillStyle = `rgba(${intensity}, ${intensity}, ${intensity}, ${alpha})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Add subtle glow effect
                if (point.depth > 0.3) {
                    ctx.fillStyle = `rgba(${intensity}, ${intensity}, ${intensity}, ${alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Add visual effects
            draw3DEffects(ctx, width, height);
        }
        
        function drawHeatMap(ctx, heatMapData, width, height) {
            // Clear canvas with dark background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.95)';
            ctx.fillRect(0, 0, width, height);
            
            // Create heat map using intensity values
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const index = y * width + x;
                    if (index < heatMapData.length) {
                        const intensity = heatMapData[index];
                        
                        // Convert intensity to heat map color
                        const heatColor = getHeatMapColor(intensity);
                        
                        ctx.fillStyle = heatColor;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }
            
            // Add heat map legend
            drawHeatMapLegend(ctx, width, height);
            
            // Add contour lines for better visualization
            drawContourLines(ctx, heatMapData, width, height);
        }
        
        function getHeatMapColor(intensity) {
            // Normalize intensity to 0-1 range
            const normalized = intensity / 255;
            
            // Create heat map color gradient
            // Blue (cold) -> Green -> Yellow -> Red (hot)
            let r, g, b;
            
            if (normalized < 0.25) {
                // Blue to Cyan
                const t = normalized * 4;
                r = 0;
                g = Math.floor(t * 255);
                b = 255;
            } else if (normalized < 0.5) {
                // Cyan to Green
                const t = (normalized - 0.25) * 4;
                r = 0;
                g = 255;
                b = Math.floor((1 - t) * 255);
            } else if (normalized < 0.75) {
                // Green to Yellow
                const t = (normalized - 0.5) * 4;
                r = Math.floor(t * 255);
                g = 255;
                b = 0;
            } else {
                // Yellow to Red
                const t = (normalized - 0.75) * 4;
                r = 255;
                g = Math.floor((1 - t) * 255);
                b = 0;
            }
            
            // Add some transparency for overlay effect
            const alpha = Math.max(0.6, normalized * 0.8);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function drawHeatMapLegend(ctx, width, height) {
            // Draw color legend on the right side
            const legendWidth = 20;
            const legendHeight = height - 40;
            const legendX = width - legendWidth - 10;
            const legendY = 20;
            
            // Create gradient for legend
            const gradient = ctx.createLinearGradient(0, legendY, 0, legendY + legendHeight);
            gradient.addColorStop(0, 'rgba(0, 0, 255, 0.8)');     // Blue (cold)
            gradient.addColorStop(0.33, 'rgba(0, 255, 255, 0.8)'); // Cyan
            gradient.addColorStop(0.66, 'rgba(0, 255, 0, 0.8)');   // Green
            gradient.addColorStop(0.83, 'rgba(255, 255, 0, 0.8)'); // Yellow
            gradient.addColorStop(1, 'rgba(255, 0, 0, 0.8)');     // Red (hot)
            
            ctx.fillStyle = gradient;
            ctx.fillRect(legendX, legendY, legendWidth, legendHeight);
            
            // Add legend labels
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.font = '10px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('High', legendX + legendWidth + 5, legendY + 10);
            ctx.fillText('Low', legendX + legendWidth + 5, legendY + legendHeight - 5);
        }
        
        function drawContourLines(ctx, heatMapData, width, height) {
            // Draw contour lines to show intensity levels
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            
            const contourLevels = [0.2, 0.4, 0.6, 0.8];
            
            contourLevels.forEach(level => {
                const threshold = level * 255;
                
                ctx.beginPath();
                let hasStarted = false;
                
                for (let y = 0; y < height; y += 2) {
                    for (let x = 0; x < width; x += 2) {
                        const index = y * width + x;
                        if (index < heatMapData.length) {
                            const currentIntensity = heatMapData[index];
                            const nextIntensity = (index + 2 < heatMapData.length) ? heatMapData[index + 2] : currentIntensity;
                            
                            // Check for contour crossing
                            if ((currentIntensity < threshold && nextIntensity >= threshold) ||
                                (currentIntensity >= threshold && nextIntensity < threshold)) {
                                
                                if (!hasStarted) {
                                    ctx.moveTo(x, y);
                                    hasStarted = true;
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            }
                        }
                    }
                }
                ctx.stroke();
            });
        }
        
        function rotatePoint(point, rotX, rotY) {
            // Rotate around X axis
            const cosX = Math.cos(rotX);
            const sinX = Math.sin(rotX);
            const y1 = point.y * cosX - point.z * sinX;
            const z1 = point.y * sinX + point.z * cosX;
            
            // Rotate around Y axis
            const cosY = Math.cos(rotY);
            const sinY = Math.sin(rotY);
            const x2 = point.x * cosY + z1 * sinY;
            const z2 = -point.x * sinY + z1 * cosY;
            
            return { x: x2, y: y1, z: z2 };
        }
        
        function draw3DEffects(ctx, width, height) {
            // Add subtle grid lines for 3D reference
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            
            // Vertical grid lines
            for (let i = 0; i < width; i += 25) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let i = 0; i < height; i += 25) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(width, i);
                ctx.stroke();
            }
            
            // Add interaction instructions
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Drag to rotate', width / 2, height - 10);
        }
        
        function add3DInteractivity(ctx, width, height) {
            const canvas = document.getElementById('3dCanvas');
            if (!canvas) return;
            
            // Mouse events for rotation
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaX = e.clientX - lastMouseX;
                const deltaY = e.clientY - lastMouseY;
                
                // Update rotation based on mouse movement
                rotationY += deltaX * 0.01;
                rotationX += deltaY * 0.01;
                
                // Limit vertical rotation to prevent flipping
                rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                // Redraw the 3D visualization
                if (depthMap) {
                    draw3DVisualization(ctx, depthMap, width, height);
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            // Touch events for mobile devices
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDragging = true;
                const touch = e.touches[0];
                lastMouseX = touch.clientX;
                lastMouseY = touch.clientY;
            });
            
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDragging) return;
                
                const touch = e.touches[0];
                const deltaX = touch.clientX - lastMouseX;
                const deltaY = touch.clientY - lastMouseY;
                
                rotationY += deltaX * 0.01;
                rotationX += deltaY * 0.01;
                
                rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
                
                lastMouseX = touch.clientX;
                lastMouseY = touch.clientY;
                
                if (depthMap) {
                    draw3DVisualization(ctx, depthMap, width, height);
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                isDragging = false;
            });
            
            // Set initial cursor style
            canvas.style.cursor = 'grab';
        }
        
        function useDemo() {
            // Simulate demo file selection with a demo image
            const demoImageUrl = 'data:image/svg+xml;base64,' + btoa(`
                <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <radialGradient id="grad" cx="50%" cy="50%" r="50%">
                            <stop offset="0%" style="stop-color:white;stop-opacity:1" />
                            <stop offset="100%" style="stop-color:black;stop-opacity:1" />
                        </radialGradient>
                    </defs>
                    <rect width="200" height="200" fill="url(#grad)"/>
                    <circle cx="100" cy="80" r="30" fill="rgba(255,255,255,0.3)"/>
                    <ellipse cx="100" cy="120" rx="40" ry="20" fill="rgba(255,255,255,0.2)"/>
                    <rect x="80" y="140" width="40" height="20" fill="rgba(255,255,255,0.4)"/>
                </svg>
            `);
            
            selectedFile = { name: 'demo_chest_xray.jpg', size: 2.5 * 1024 * 1024 };
            
            // Update upload area with demo content
            const uploadArea = document.querySelector('.upload-area');
            const analyzeBtn = document.getElementById('analyzeBtn');
            
            uploadArea.innerHTML = `
                <div class="upload-icon">âœ…</div>
                <div class="upload-text">File Selected: ${selectedFile.name}</div>
                <div class="upload-subtext">Size: ${(selectedFile.size / 1024 / 1024).toFixed(2)} MB</div>
                
                <div class="image-previews">
                    <div class="preview-container">
                        <h4>Original 2D Image</h4>
                        <img src="${demoImageUrl}" alt="Demo Image" class="preview-image" id="originalImage">
                    </div>
                    <div class="preview-container">
                        <h4>Heat Map Analysis</h4>
                        <canvas id="heatmapCanvas"></canvas>
                    </div>
                    <div class="preview-container">
                        <h4>3D Visualization</h4>
                        <canvas id="3dCanvas"></canvas>
                    </div>
                </div>
            `;
            
            // Reset rotation for demo
            rotationX = 0;
            rotationY = 0;
            
            // Generate both 3D preview and heat map for demo
            generate3DPreview(demoImageUrl);
            generateHeatMap(demoImageUrl);
            analyzeBtn.disabled = false;
            showAlert('Demo image loaded! View the heat map analysis and drag the 3D visualization to rotate it. You can now start the analysis.', 'success');
        }
        
        // Analysis
        function startAnalysis() {
            if (!selectedFile) {
                showAlert('Please select a file first.', 'error');
                return;
            }
            
            document.getElementById('loading').style.display = 'block';
            document.getElementById('analysisResults').style.display = 'none';
            
            // Simulate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress > 100) {
                    progress = 100;
                    clearInterval(progressInterval);
                    showAnalysisResults();
                }
                document.getElementById('progressFill').style.width = progress + '%';
            }, 500);
        }
        
        function showAnalysisResults() {
            // Get random values from arrays
            const randomConfidence = confidenceValues[Math.floor(Math.random() * confidenceValues.length)] / 100;
            const randomProcessingTime = parseFloat(processingTimes[Math.floor(Math.random() * processingTimes.length)]);
            const randomRiskLevel = riskLevels[Math.floor(Math.random() * riskLevels.length)];
            
            // Generate random confidence for individual findings (75-100%)
            const findingConfidence1 = confidenceValues[Math.floor(Math.random() * confidenceValues.length)] / 100;
            const findingConfidence2 = confidenceValues[Math.floor(Math.random() * confidenceValues.length)] / 100;
            const findingConfidence3 = confidenceValues[Math.floor(Math.random() * confidenceValues.length)] / 100;
            
            // Generate recommendations based on risk level
            let recommendations = [];
            if (randomRiskLevel === 'Low') {
                recommendations = [
                    "Routine follow-up as clinically indicated",
                    "No acute intervention required"
                ];
            } else if (randomRiskLevel === 'Medium') {
                recommendations = [
                    "Close monitoring recommended",
                    "Consider follow-up imaging in 2-4 weeks",
                    "Patient education on symptom monitoring"
                ];
            } else {
                recommendations = [
                    "Immediate clinical evaluation recommended",
                    "Consider urgent imaging or specialist consultation",
                    "Close patient monitoring required"
                ];
            }
            
            // Log the random values for debugging
            console.log('Random Analysis Values:');
            console.log('Overall Confidence:', (randomConfidence * 100).toFixed(1) + '%');
            console.log('Processing Time:', randomProcessingTime + 's');
            console.log('Risk Level:', randomRiskLevel);
            console.log('Finding Confidences:', [
                (findingConfidence1 * 100).toFixed(1) + '%',
                (findingConfidence2 * 100).toFixed(1) + '%',
                (findingConfidence3 * 100).toFixed(1) + '%'
            ]);
            
            // Simulate analysis results with random values
            const results = {
                primaryFindings: [
                    { description: "No acute cardiopulmonary process", confidence: findingConfidence1 },
                    { description: "Normal heart size and mediastinal contours", confidence: findingConfidence2 },
                    { description: "Clear lung fields bilaterally", confidence: findingConfidence3 }
                ],
                overallConfidence: randomConfidence,
                quantumEnhanced: true,
                processingTime: randomProcessingTime,
                riskAssessment: randomRiskLevel,
                recommendations: recommendations
            };
            
            // Add to history
            analysisHistory.push({
                filename: selectedFile.name,
                timestamp: new Date(),
                results: results
            });
            
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('analysisResults').style.display = 'block';
                
                const resultsHtml = `
                    <div class="result-card">
                        <h4> Primary Findings</h4>
                        ${results.primaryFindings.map(finding => `
                            <div style="margin: 15px 0;">
                                <strong>${finding.description}</strong>
                                <div class="confidence-meter">
                                    <span>Confidence:</span>
                                    <div class="confidence-bar">
                                        <div class="confidence-fill ${getConfidenceClass(finding.confidence)}" 
                                             style="width: ${finding.confidence * 100}%"></div>
                                    </div>
                                    <span>${(finding.confidence * 100).toFixed(1)}%</span>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="result-card">
                        <h4> Analysis Metrics</h4>
                        <div class="dashboard-grid">
                            <div class="metric-card">
                                <div class="metric-value">${(results.overallConfidence * 100).toFixed(1)}%</div>
                                <div class="metric-label">Overall Confidence</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${results.quantumEnhanced ? 'âœ…' : 'âŒ'}</div>
                                <div class="metric-label">Quantum Enhanced</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${results.processingTime}s</div>
                                <div class="metric-label">Processing Time</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value">${results.riskAssessment}</div>
                                <div class="metric-label">Risk Level</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <h4> Clinical Recommendations</h4>
                        <ul style="line-height: 1.8;">
                            ${results.recommendations.map(rec => `<li>${rec}</li>`).join('')}
                        </ul>
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button class="btn" onclick="generateReport()">ðŸ“„ Generate PDF Report</button>
                        <button class="btn btn-secondary" onclick="explainFindings()">ðŸ” Explain Findings</button>
                    </div>
                `;
                
                document.getElementById('resultsContent').innerHTML = resultsHtml;
                updateDashboard();
                showAlert('Analysis completed successfully!', 'success');
            }, 1000);
        }
        
        function getConfidenceClass(confidence) {
            if (confidence >= 0.8) return 'confidence-high';
            if (confidence >= 0.6) return 'confidence-medium';
            return 'confidence-low';
        }
        
        // Chat functionality
        function handleChatKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Add user message
            addChatMessage(message, 'user');
            input.value = '';
            
            // Simulate AI response
            setTimeout(() => {
                const responses = [
                    "Based on the analysis, the findings suggest a normal chest X-ray with no acute abnormalities. The quantum-enhanced processing achieved high confidence levels across all findings.",
                    "The explainable AI components (Grad-CAM, LIME, SHAP) highlight the key anatomical structures that contributed to the diagnosis. Would you like me to explain any specific finding in more detail?",
                    "The risk stratification indicates low clinical risk, which aligns with the normal imaging findings. The recommendations suggest routine follow-up care.",
                    "I can provide more detailed explanations about the quantum enhancement benefits or the specific medical terminology used in the report. What would you like to know more about?"
                ];
                
                const randomResponse = responses[Math.floor(Math.random() * responses.length)];
                addChatMessage(randomResponse, 'assistant');
            }, 1000);
        }
        
        function addChatMessage(message, sender) {
            const container = document.getElementById('chatContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${sender}`;
            
            if (sender === 'assistant') {
                messageDiv.innerHTML = `<strong>Medical AI:</strong> ${message}`;
            } else {
                messageDiv.innerHTML = `<strong>You:</strong> ${message}`;
            }
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
        }
        
        // Dashboard updates
        function updateDashboard() {
            if (analysisHistory.length === 0) return;
            
            const totalAnalyses = analysisHistory.length;
            const avgConfidence = analysisHistory.reduce((sum, item) => 
                sum + item.results.overallConfidence, 0) / totalAnalyses;
            const quantumEnhanced = analysisHistory.filter(item => 
                item.results.quantumEnhanced).length / totalAnalyses;
            const avgProcessingTime = analysisHistory.reduce((sum, item) => 
                sum + item.results.processingTime, 0) / totalAnalyses;
            
            document.getElementById('totalAnalyses').textContent = totalAnalyses;
            document.getElementById('avgConfidence').textContent = (avgConfidence * 100).toFixed(1) + '%';
            document.getElementById('quantumEnhanced').textContent = (quantumEnhanced * 100).toFixed(1) + '%';
            document.getElementById('processingTime').textContent = avgProcessingTime.toFixed(1) + 's';
            
            // Update recent activity
            const recentActivity = document.getElementById('recentActivity');
            const activityHtml = analysisHistory.slice(-5).reverse().map(item => `
                <div style="padding: 10px 0; border-bottom: 1px solid #eee;">
                    <strong>${item.filename}</strong>
                    <span style="float: right; color: #6c757d;">
                        ${item.timestamp.toLocaleTimeString()}
                    </span>
                    <br>
                    <small style="color: #6c757d;">
                        Confidence: ${(item.results.overallConfidence * 100).toFixed(1)}% | 
                        Risk: ${item.results.riskAssessment}
                    </small>
                </div>
            `).join('');
            
            recentActivity.innerHTML = activityHtml;
        }
        
        // Utility functions
        function showAlert(message, type) {
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            
            document.querySelector('.main-content').insertBefore(alert, 
                document.querySelector('.tabs').nextSibling);
            
            setTimeout(() => {
                alert.remove();
            }, 5000);
        }
        
        function generateReport() {
            showAlert('PDF report generation started. Download will begin shortly.', 'success');
            // In a real implementation, this would call the API to generate a PDF
        }
        
        function explainFindings() {
            switchTab('chat');
            document.getElementById('chatInput').value = 'Can you explain the findings from my recent analysis in more detail?';
            setTimeout(() => sendMessage(), 500);
        }
        
        // Window resize handler for responsive canvases
        window.addEventListener('resize', function() {
            // Re-generate canvases if they exist
            const heatmapCanvas = document.getElementById('heatmapCanvas');
            const canvas3D = document.getElementById('3dCanvas');
            
            if (heatmapCanvas && depthMap) {
                // Re-generate heat map with new size
                setTimeout(() => {
                    const ctx = heatmapCanvas.getContext('2d');
                    const container = heatmapCanvas.parentElement;
                    const maxSize = Math.min(container.clientWidth - 30, 250);
                    heatmapCanvas.width = maxSize;
                    heatmapCanvas.height = maxSize;
                    
                    // Re-draw heat map
                    drawHeatMap(ctx, depthMap, heatmapCanvas.width, heatmapCanvas.height);
                }, 100);
            }
            
            if (canvas3D && depthMap) {
                // Re-generate 3D visualization with new size
                setTimeout(() => {
                    const ctx = canvas3D.getContext('2d');
                    const container = canvas3D.parentElement;
                    const maxSize = Math.min(container.clientWidth - 30, 250);
                    canvas3D.width = maxSize;
                    canvas3D.height = maxSize;
                    
                    // Re-draw 3D visualization
                    draw3DVisualization(ctx, depthMap, canvas3D.width, canvas3D.height);
                }, 100);
            }
        });

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Add some demo data to dashboard
            console.log('Quantum-Enhanced Medical Imaging AI System initialized');
        });
    </script>
</body>
</html>